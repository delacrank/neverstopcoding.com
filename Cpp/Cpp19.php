<!DOCTYPE html>
<html>
    <head><meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html;
	   charset=utf-8" />
        <title>Data Converisons - Cpp Programming</title>
        <link href='http://fonts.googleapis.com/css?family=Varela+Round' rel="stylesheet"><link href='http://fonts.googleapis.com/css?family=Cormorant+Infant' rel="stylesheet"><link rel="stylesheet"
              type="text/css"
              href="../testcss.css">
    </head>
<body>
    
 <!-- Header -->
<?php include('..//Includes//header.php'); ?>

<!-- Navigation -->
<?php include('..//Includes//nav.php'); ?>
    
<!-- Navigation2 -->
<?php include('..//Includes//nav2.php'); ?>
    
<!-- Left --><div class = "mainWrapper">
<?php include('..//Includes//Left_Cpp.php'); ?>

<!-- Right -->
    
    <div id ="rightz">

        <h1>Data Converisons - Cpp Development</h1>
      
        <h2>Data Converisons</h2>
        
            <p>Conversions happen when two differing data types are forced to use a common operator. A simple example of this would be when adding an integer to a double, what is the sum an int or a double?
        
        <span class ="nl">If we force the two together than data can be lost because a double stores 64 bits of data while an int only stores 32 bits.  If the sum is computed in the form of an int then the double is also computed as an int and the sum is truncated to hold only 32 bits instead of 64.</span>
                
        <span class="nl">However, data conversions usually work the other way around, where the smaller data type is converted to a larger one.  In the case of a char and an int being force to used an operator both types will be converted to a int. This holds true for a int and a float (both will be float), float and a double (both will be double), double and a double long (both will be double long), etc.</span>
                
        <span class="nl">The only exception to this is an unsigned type, where the conversion will be based on the length of the unsigned data type.  We know there are 256 outcomes in 1 byte, a signed byte holds 127 positive values and 128 negative values. An unsigned byte holds 255 positive values.  A chart containing all the ranges can be found <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz.aspx" target="_blank">here</a>.</span>
                
        <span class="nl">You will find that compound data types such as a pointer and a reference will require at least 8 bytes reguardless of the type in order to store the address, they will require only 4 bytes or 1 byte to store the value depending on the type.  This can be further examined by using the 'sizeof' operator.</span>
              </p>
        
    <em>Code:</em>
    <!-- code -->
    <pre class="code">
    char *p;
    
    cout &lt;&lt; sizeof(*p) &lt;&lt; endl;
    cout &lt;&lt; sizeof(p) &lt;&lt; endl;</pre>
        
        <p>So far all the conversions I have spoken about were pertaining only to implicit conversions where the compiler sees the two types and converts one to the other based on the context of the expression.
        
        <span class = "nl">Next we will talk of explicit conversions or type casting where we can use something called a cast to tell our compiler how to execute an operand.</span>
              </p>
        
    <hr />    
        
        <!-- Named casts -->
        <h3>Named Casts</h3>
        
            <p>There are three types of 'named casts' we can use to explicity convert one data type to another.  The first is called a 'static_cast' it is useful for converting a smaller type when used inconjunctions with a larger type.  It let's the compiler and the programmer know that we are not concerned with the loss of data.</p>
        
    <em>Code:</em>
    <!-- code -->
    <pre class="code">
    double d;
    void* p = &amp;d;
    double *dp = static_cast&lt;double*>(p);</pre>
        
            <p>In the example above we stored the address to a double in a void type and converted it below using our static_cast. Had we not casted the object we would have a compiler error about the invalid conversion.</p>
        
    <hr />
        
        <!-- const cast -->
        <h3>Const Cast</h3>
        
            <p>Const char is for casting data types with the const qualifer, this is for when want to deal with low-level const objects as the base with a non-const pointer (top level).
        
        <span class = "nl">Only a 'const' pointer can point to a 'const' object, but with Const casting the right hand operand in this expression will allow us to compute a non-const Lvalue with a const Rvalue.</span>
              </p>
        
    <em>Code:</em>
    <!-- code -->
    <pre class="code">
    const char *pc;
    char *p = const_cast&lt;char*>(pc);</pre>
        
    <hr />
        
        <!-- reinterpret cast -->
        <h3>Reinterpret Cast</h3>
            
            <p>Reinterpret Cast can be used for conversions such as changing an int to a char, this operator is volatile and is used at great risk.</p>
        
    <em>Code:</em>
    <!-- code -->
    <pre class="code">
    int *ip;
    char *pc = reinterpret_cast&lt;char*>(ip);</pre>
        
    <hr />
        
        <!-- c style -->
        <h3>C style casting</h3>
        
            <p>The way we cast objects in c is by defining the type of the new data type by putting paranthese over our new data type. This informs the compiler of the change we want.</p>
        
    <em>Code:</em>
    <!-- code -->
    <pre class="code">
    int c = 5;
    char x = (char)c;</pre>
        
        <hr />
        <br />
        <a href="Cpp18.html">Previous</a>
        <span class = "next">
        <a href = "Cpp20.html">Next Page</a></span>
        <br /><br />

    </div>    
    
</div><!-- Footer -->
<?php include('..//Includes//footer.php'); ?>

</body>
</html>  